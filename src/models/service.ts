/**
 * VerizonLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import {
  array,
  boolean,
  lazy,
  nullable,
  object,
  optional,
  Schema,
  string,
} from '../schema';
import { Boundary, boundarySchema } from './boundary';
import { Compatibility, compatibilitySchema } from './compatibility';
import {
  EdgeServiceOnboardingResult,
  edgeServiceOnboardingResultSchema,
} from './edgeServiceOnboardingResult';
import {
  ObservabilityTemplate,
  observabilityTemplateSchema,
} from './observabilityTemplate';
import { ServiceDependency, serviceDependencySchema } from './serviceDependency';
import { ServiceError, serviceErrorSchema } from './serviceError';
import { ServiceHandlerId, serviceHandlerIdSchema } from './serviceHandlerId';
import {
  ServiceOnboardingAdditionalParams,
  serviceOnboardingAdditionalParamsSchema,
} from './serviceOnboardingAdditionalParams';
import { ServiceResource, serviceResourceSchema } from './serviceResource';
import { ServiceStateEnum, serviceStateEnumSchema } from './serviceStateEnum';
import { ServiceStatusEnum, serviceStatusEnumSchema } from './serviceStatusEnum';
import {
  ServiceSwaggerSpecId,
  serviceSwaggerSpecIdSchema,
} from './serviceSwaggerSpecId';
import { ServiceTag, serviceTagSchema } from './serviceTag';
import { ServiceTypeEnum, serviceTypeEnumSchema } from './serviceTypeEnum';
import { Workflow, workflowSchema } from './workflow';
import { Workload, workloadSchema } from './workload';

/** A customer service on 5G MEC platform using 5G MEC portal. */
export interface Service {
  /** System generated unique UUID. */
  id?: string;
  /** Name of the service needs to be deployed. */
  name: string;
  /** Description of the service needs to be deployed. */
  description?: string | null;
  /** Version of the service needs to be deployed. */
  version: string;
  /** Properties are metadata attributes. */
  metadata?: ServiceOnboardingAdditionalParams[];
  /** List of service tags. */
  tags?: ServiceTag[];
  /** Can be any name just to define it under a category. */
  categories?: string[] | null;
  /** Boolean value to set/unset the service as favorite. */
  isFavourite?: boolean;
  /** Boolean to support soft delete of a version of a service. */
  isDeleted?: boolean;
  /** Compatibility would have the attribute CSP which is Cloud service provider e.g. AWS_PUBLIC_CLOUD, AWS_WL, AWS_OUTPOST, AZURE_EDGE, AZURE_PUBLIC_CLOUD. */
  compatibility?: Compatibility[];
  /** Resource of the service. */
  resource?: ServiceResource;
  /** Auto-derived time of creation. Part of response only. */
  createdDate?: string;
  /** Last modified time. Part of response only. */
  lastModifiedDate?: string;
  /** User who created the service. Part of response only. */
  createdBy?: string;
  /** User who last modified the service. Part of response only. */
  lastModifiedBy?: string;
  /** Errors related to service. */
  error?: ServiceError;
  /** Error response attribute of a service. */
  errorResponse?: EdgeServiceOnboardingResult;
  /** Can have any value as - DRAFT, DESIGN, TESTING, PUBLISH, CERTIFY, READY_TO_USE, DEPRECATE, DELETED. */
  state?: ServiceStateEnum;
  /** Can have any value as - DRAFT_INPROGRESS, DRAFT_COMPLETE, DESIGN_INPROGRESS, DESIGN_FAILED, DESIGN_COMPLETED, VALIDATION_INPROGRESS,  VALIDATION_FAILED, VALIDATION_COMPLETED, TESTING_INPROGRESS, TESTING_FAILED, TESTING_COMPLETED, READY_TO_USE_INPROGRESS, READY_TO_USE_FAILED, READY_TO_USE_COMPLETED, READY_TO_PRIVATE_USE_INPROGRESS, READY_TO_PRIVATE_USE_FAILED, READY_TO_PRIVATE_USE_COMPLETED,  PUBLISH_INPROGRESS,  PUBLISH_FAILED,  PUBLISH_COMPLETED,  CERTIFY_INPROGRESS,  CERTIFY_FAILED, CERTIFY_COMPLETED, DEPRECATE_INPROGRESS,  DEPRECATE_FAILED, DEPRECATE_COMPLETED, MARKDELETE_INPROGRESS, MARKDELETE_FAILED, MARKDELETE_COMPLETED. */
  status?: ServiceStatusEnum;
  /** Service Type e.g. Installation, Operations, Custom. */
  type?: ServiceTypeEnum;
  /** Auto-generated Id of serviceHandlerId created. */
  serviceHandlerId?: ServiceHandlerId;
  /** Attribute of service. */
  observabilityTemplate?: ObservabilityTemplate;
  /** Auto-generated Id of service handler Swagger specification file uploaded. */
  serviceSwaggerSpecId?: ServiceSwaggerSpecId;
  workflows?: Workflow[];
  workloads?: Workload[];
  /** Dependencies of the service. */
  dependencies?: ServiceDependency[];
  /** Boundaries would have attributes csp, region and zoneId. */
  boundaries?: Boundary[] | null;
}

export const serviceSchema: Schema<Service> = object({
  id: ['id', optional(string())],
  name: ['name', string()],
  description: ['description', optional(nullable(string()))],
  version: ['version', string()],
  metadata: [
    'metadata',
    optional(array(lazy(() => serviceOnboardingAdditionalParamsSchema))),
  ],
  tags: ['tags', optional(array(lazy(() => serviceTagSchema)))],
  categories: ['categories', optional(nullable(array(string())))],
  isFavourite: ['isFavourite', optional(boolean())],
  isDeleted: ['isDeleted', optional(boolean())],
  compatibility: [
    'compatibility',
    optional(array(lazy(() => compatibilitySchema))),
  ],
  resource: ['resource', optional(lazy(() => serviceResourceSchema))],
  createdDate: ['createdDate', optional(string())],
  lastModifiedDate: ['lastModifiedDate', optional(string())],
  createdBy: ['createdBy', optional(string())],
  lastModifiedBy: ['lastModifiedBy', optional(string())],
  error: ['error', optional(lazy(() => serviceErrorSchema))],
  errorResponse: [
    'errorResponse',
    optional(lazy(() => edgeServiceOnboardingResultSchema)),
  ],
  state: ['state', optional(serviceStateEnumSchema)],
  status: ['status', optional(serviceStatusEnumSchema)],
  type: ['type', optional(serviceTypeEnumSchema)],
  serviceHandlerId: [
    'serviceHandlerId',
    optional(lazy(() => serviceHandlerIdSchema)),
  ],
  observabilityTemplate: [
    'observabilityTemplate',
    optional(lazy(() => observabilityTemplateSchema)),
  ],
  serviceSwaggerSpecId: [
    'serviceSwaggerSpecId',
    optional(lazy(() => serviceSwaggerSpecIdSchema)),
  ],
  workflows: ['workflows', optional(array(lazy(() => workflowSchema)))],
  workloads: ['workloads', optional(array(lazy(() => workloadSchema)))],
  dependencies: [
    'dependencies',
    optional(array(lazy(() => serviceDependencySchema))),
  ],
  boundaries: [
    'boundaries',
    optional(nullable(array(lazy(() => boundarySchema)))),
  ],
});
