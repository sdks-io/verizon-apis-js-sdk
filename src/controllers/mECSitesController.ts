/**
 * VerizonLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  EdgeServiceLaunchResultError,
} from '../errors/edgeServiceLaunchResultError';
import {
  ClustersNamespaces,
  clustersNamespacesSchema,
} from '../models/clustersNamespaces';
import {
  ClusterStateEnum,
  clusterStateEnumSchema,
} from '../models/clusterStateEnum';
import {
  MECSiteLocationsResult,
  mECSiteLocationsResultSchema,
} from '../models/mECSiteLocationsResult';
import { optional, string } from '../schema';
import { BaseController } from './baseController';

export class MECSitesController extends BaseController {
  /**
   * Supports fetching MEC locations so the user can view the city.
   *
   * @param accountName User account name.
   * @return Response from the API call
   */
  async listMECSiteLocations(
    accountName?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MECSiteLocationsResult>> {
    const req = this.createRequest('GET', '/v1/mecsite/locations');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.throwOn(400, EdgeServiceLaunchResultError, 'Error Response.');
    return req.callAsJson(mECSiteLocationsResultSchema, requestOptions);
  }

  /**
   * Retrieve all clusters for the customer.
   *
   * @param userId
   * @param role
   * @param customerId
   * @param requestId
   * @param eRN
   * @param name
   * @param offset
   * @param limit
   * @param correlationId
   * @param clusterState
   * @return Response from the API call
   */
  async listERNClusterNamespaces(
    userId: string,
    role: string,
    customerId: string,
    requestId: string,
    eRN?: string,
    name?: string,
    offset?: string,
    limit?: string,
    correlationId?: string,
    clusterState?: ClusterStateEnum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ClustersNamespaces>> {
    const req = this.createRequest('GET', '/v1/platform/clusters');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      role: [role, string()],
      customerId: [customerId, string()],
      requestId: [requestId, string()],
      eRN: [eRN, optional(string())],
      name: [name, optional(string())],
      offset: [offset, optional(string())],
      limit: [limit, optional(string())],
      correlationId: [correlationId, optional(string())],
      clusterState: [clusterState, optional(clusterStateEnumSchema)],
    });
    req.header('userId', mapped.userId);
    req.header('role', mapped.role);
    req.header('customerId', mapped.customerId);
    req.header('requestId', mapped.requestId);
    req.header('correlationId', mapped.correlationId);
    req.query('ERN', mapped.eRN);
    req.query('name', mapped.name);
    req.query('offset', mapped.offset);
    req.query('limit', mapped.limit);
    req.query('cluster_state', mapped.clusterState);
    req.throwOn(400, EdgeServiceLaunchResultError, 'Bad Request.');
    req.throwOn(404, EdgeServiceLaunchResultError, 'Not found.');
    req.throwOn(500, EdgeServiceLaunchResultError, 'Internal Server Error.');
    req.defaultToError(EdgeServiceLaunchResultError, 'Unexpected error.');
    return req.callAsJson(clustersNamespacesSchema, requestOptions);
  }
}
