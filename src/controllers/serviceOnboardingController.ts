/**
 * VerizonLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, FileWrapper, RequestOptions } from '../core';
import {
  EdgeServiceOnboardingResultError,
} from '../errors/edgeServiceOnboardingResultError';
import {
  CategoryTypeEnum,
  categoryTypeEnumSchema,
} from '../models/categoryTypeEnum';
import {
  ClusterInfoDetails,
  clusterInfoDetailsSchema,
} from '../models/clusterInfoDetails';
import { CurrentStatus, currentStatusSchema } from '../models/currentStatus';
import {
  EdgeServiceOnboardingDeleteResult,
  edgeServiceOnboardingDeleteResultSchema,
} from '../models/edgeServiceOnboardingDeleteResult';
import { Service, serviceSchema } from '../models/service';
import { ServiceFile, serviceFileSchema } from '../models/serviceFile';
import {
  ServiceManagementResult,
  serviceManagementResultSchema,
} from '../models/serviceManagementResult';
import { Services, servicesSchema } from '../models/services';
import {
  SortDirectionEnum,
  sortDirectionEnumSchema,
} from '../models/sortDirectionEnum';
import { bigint, boolean, optional, string } from '../schema';
import { BaseController } from './baseController';

export class ServiceOnboardingController extends BaseController {
  /**
   * Upload workload payload/package in the MEC platform.
   *
   * @param accountName     User account name.
   * @param serviceName     Service name to which the file is going to be associated.
   * @param version         Version of the service being used.
   * @param categoryType    Type of the file being uploaded.
   * @param categoryName    `workloadName` used in the service while creation.
   * @param payload         Payload/file which is to be uploaded should be provided in formData.
   * @param correlationId
   * @param categoryVersion It is mandatory for only service file, not mandatory for workload and
   *                                            workflow file.
   * @return Response from the API call
   */
  async uploadServiceWorkloadFile(
    accountName: string,
    serviceName: string,
    version: string,
    categoryType: CategoryTypeEnum,
    categoryName: string,
    payload: FileWrapper,
    correlationId?: string,
    categoryVersion?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ServiceFile>> {
    const req = this.createRequest('POST');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      serviceName: [serviceName, string()],
      version: [version, string()],
      categoryType: [categoryType, categoryTypeEnumSchema],
      categoryName: [categoryName, string()],
      correlationId: [correlationId, optional(string())],
      categoryVersion: [categoryVersion, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.query('categoryType', mapped.categoryType);
    req.query('categoryName', mapped.categoryName);
    req.query('categoryVersion', mapped.categoryVersion);
    req.formData({
      payload: payload,
    });
    req.appendTemplatePath`/v1/files/${mapped.serviceName}/${mapped.version}/uploadAndValidate`;
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(404, EdgeServiceOnboardingResultError, 'Not found.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    return req.callAsJson(serviceFileSchema, requestOptions);
  }

  /**
   * Fetch all organizational services in the platform.
   *
   * @param accountName   User account name.
   * @param correlationId
   * @param name          Name of the service whose information needs to be fetched.
   * @param q             Use the comma (:) character to separate multiple values eg
   *                                           type=myService:workloads.packageType=Helm,YAML:state=DRAFTED,
   *                                           VALIDATION_COMPLETED.
   * @param limit         Number of items to return.
   * @param offSet        Id of the last respose value in the previous list.
   * @param sortKey       Sorts the response by an attribute. Default is createdDate.
   * @param sortDir       Sorts the response. Use asc for ascending or desc for descending order.
   *                                           The default is desc.
   * @param detailsFlag   Default as true. If it is true, then it will return all details.
   * @return Response from the API call
   */
  async listServices(
    accountName: string,
    correlationId?: string,
    name?: string,
    q?: string,
    limit?: bigint,
    offSet?: bigint,
    sortKey?: string,
    sortDir?: SortDirectionEnum,
    detailsFlag?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Services>> {
    const req = this.createRequest('GET', '/v1/services');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      correlationId: [correlationId, optional(string())],
      name: [name, optional(string())],
      q: [q, optional(string())],
      limit: [limit, optional(bigint())],
      offSet: [offSet, optional(bigint())],
      sortKey: [sortKey, optional(string())],
      sortDir: [sortDir, optional(sortDirectionEnumSchema)],
      detailsFlag: [detailsFlag, optional(boolean())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.query('name', mapped.name);
    req.query('q', mapped.q);
    req.query('limit', mapped.limit);
    req.query('offSet', mapped.offSet);
    req.query('sortKey', mapped.sortKey);
    req.query('sortDir', mapped.sortDir);
    req.query('detailsFlag', mapped.detailsFlag);
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(404, EdgeServiceOnboardingResultError, 'Not Found.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    return req.callAsJson(servicesSchema, requestOptions);
  }

  /**
   * Create a new service within user's organization.
   *
   * @param accountName   User account name.
   * @param body
   * @param correlationId
   * @return Response from the API call
   */
  async registerService(
    accountName: string,
    body: Service,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Service>> {
    const req = this.createRequest('POST', '/v1/services');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      body: [body, serviceSchema],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('Content-Type', 'application/json');
    req.header('correlationId', mapped.correlationId);
    req.json(mapped.body);
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(403, EdgeServiceOnboardingResultError, 'Forbidden.');
    req.throwOn(404, EdgeServiceOnboardingResultError, 'Not found.');
    req.throwOn(415, EdgeServiceOnboardingResultError, 'Unsupported media type.');
    req.throwOn(429, EdgeServiceOnboardingResultError, 'Too many requests.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    return req.callAsJson(serviceSchema, requestOptions);
  }

  /**
   * Fetch a service details within user's organization using service name and version.
   *
   * @param accountName   User account name.
   * @param serviceName   Name of the service whose information needs to be fetched.
   * @param version       Version of service whose information needs to be fetched.
   * @param correlationId
   * @return Response from the API call
   */
  async listServiceDetails(
    accountName: string,
    serviceName: string,
    version: string,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Service>> {
    const req = this.createRequest('GET');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      serviceName: [serviceName, string()],
      version: [version, string()],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.appendTemplatePath`/v1/services/${mapped.serviceName}/${mapped.version}`;
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(404, EdgeServiceOnboardingResultError, 'Not Found.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    req.defaultToError(EdgeServiceOnboardingResultError, 'Unexpected error.');
    return req.callAsJson(serviceSchema, requestOptions);
  }

  /**
   * Remove a service from user's organization.
   *
   * @param accountName   User account name.
   * @param serviceName   Name of the service which is about to be deleted.
   * @param version       Version of the service which is about to be deleted.
   * @param correlationId
   * @return Response from the API call
   */
  async removeService(
    accountName: string,
    serviceName: string,
    version: string,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EdgeServiceOnboardingDeleteResult>> {
    const req = this.createRequest('DELETE');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      serviceName: [serviceName, string()],
      version: [version, string()],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.appendTemplatePath`/v1/services/${mapped.serviceName}/${mapped.version}`;
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(404, EdgeServiceOnboardingResultError, 'Not found.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    return req.callAsJson(
      edgeServiceOnboardingDeleteResultSchema,
      requestOptions
    );
  }

  /**
   * Start service onboarding process to kick off service artifact validation and making the service
   * ready for sandbox testing. On successful completion of this process system will generate claims for
   * each selected cloud provider using which user can start sandbox testing.
   *
   * @param accountName   User account name.
   * @param serviceName   Name of the service which is to be onboarded.
   * @param version       Version of service which is to be onboarded.
   * @param correlationId
   * @return Response from the API call
   */
  async startServiceOnboarding(
    accountName: string,
    serviceName: string,
    version: string,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ServiceManagementResult>> {
    const req = this.createRequest('PUT');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      serviceName: [serviceName, string()],
      version: [version, string()],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.appendTemplatePath`/v1/services/${mapped.serviceName}/${mapped.version}/startOnboarding`;
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(403, EdgeServiceOnboardingResultError, 'Forbidden.');
    req.throwOn(404, EdgeServiceOnboardingResultError, 'Not found.');
    req.throwOn(415, EdgeServiceOnboardingResultError, 'Unsupported media type.');
    req.throwOn(429, EdgeServiceOnboardingResultError, 'Too many requests.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    return req.callAsJson(serviceManagementResultSchema, requestOptions);
  }

  /**
   * Check current status of job for a service using job ID.
   *
   * @param accountName   User account name.
   * @param jobId         Auto-generated Id of the job.
   * @param correlationId
   * @return Response from the API call
   */
  async getServiceJobStatus(
    accountName: string,
    jobId: string,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CurrentStatus>> {
    const req = this.createRequest('GET');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      jobId: [jobId, string()],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.appendTemplatePath`/v1/services/${mapped.jobId}/status`;
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(404, EdgeServiceOnboardingResultError, 'Not found.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    return req.callAsJson(currentStatusSchema, requestOptions);
  }

  /**
   * Initiate testing of a service in sandbox environment per claim based on service's compatibility(s).
   *
   * @param accountName   User account name.
   * @param serviceId     An id of the service created e.g. UUID.
   * @param claimId       Id of the claim created e.g. UUID.
   * @param body
   * @param correlationId
   * @return Response from the API call
   */
  async startServiceClaimSandBoxTesting(
    accountName: string,
    serviceId: string,
    claimId: string,
    body: ClusterInfoDetails,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ServiceManagementResult>> {
    const req = this.createRequest('PUT');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      serviceId: [serviceId, string()],
      claimId: [claimId, string()],
      body: [body, clusterInfoDetailsSchema],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('Content-Type', 'application/json');
    req.header('correlationId', mapped.correlationId);
    req.json(mapped.body);
    req.appendTemplatePath`/v1/services/${mapped.serviceId}/claims/${mapped.claimId}/sandBoxStart`;
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    req.defaultToError(EdgeServiceOnboardingResultError, 'Unexpected error.');
    return req.callAsJson(serviceManagementResultSchema, requestOptions);
  }

  /**
   * Start publishing a service. On successful completion, service's status can be marked as Publish.
   *
   * @param accountName   User account name.
   * @param serviceName   Name of the service e.g. any sub string of serviceName.
   * @param version       Version of service which is to be published.
   * @param correlationId
   * @return Response from the API call
   */
  async startServicePublishing(
    accountName: string,
    serviceName: string,
    version: string,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ServiceManagementResult>> {
    const req = this.createRequest('PUT');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      serviceName: [serviceName, string()],
      version: [version, string()],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.appendTemplatePath`/v1/services/${mapped.serviceName}/${mapped.version}/publish`;
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    req.defaultToError(EdgeServiceOnboardingResultError, 'Unexpected error.');
    return req.callAsJson(serviceManagementResultSchema, requestOptions);
  }

  /**
   * Start service certification process. On successful completion of this process, service's status will
   * change to certified.
   *
   * @param accountName   User account name.
   * @param serviceName   Name of the service e.g. any sub string of serviceName.
   * @param version       Version of service which is to be certified.
   * @param correlationId
   * @return Response from the API call
   */
  async stopServiceTesting(
    accountName: string,
    serviceName: string,
    version: string,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ServiceManagementResult>> {
    const req = this.createRequest('PUT');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      serviceName: [serviceName, string()],
      version: [version, string()],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.appendTemplatePath`/v1/services/${mapped.serviceName}/${mapped.version}/certify`;
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    req.defaultToError(EdgeServiceOnboardingResultError, 'Unexpected error.');
    return req.callAsJson(serviceManagementResultSchema, requestOptions);
  }

  /**
   * Start the process to change a service's status to "Ready to Use". On success, service's status will
   * be changed to "Ready to Use". Only a ready to use service can be deployed in production environment.
   *
   * @param accountName   User account name.
   * @param serviceName   Name of the service e.g. any sub string of serviceName.
   * @param version       Version of the service which is already certified and is ready for public use.
   * @param correlationId
   * @return Response from the API call
   */
  async markServiceAsReadyForPublicUse(
    accountName: string,
    serviceName: string,
    version: string,
    correlationId?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ServiceManagementResult>> {
    const req = this.createRequest('PUT');
    req.baseUrl('Services');
    const mapped = req.prepareArgs({
      accountName: [accountName, string()],
      serviceName: [serviceName, string()],
      version: [version, string()],
      correlationId: [correlationId, optional(string())],
    });
    req.header('AccountName', mapped.accountName);
    req.header('correlationId', mapped.correlationId);
    req.appendTemplatePath`/v1/services/${mapped.serviceName}/${mapped.version}/readyToPublicUse`;
    req.throwOn(400, EdgeServiceOnboardingResultError, 'Bad Request.');
    req.throwOn(401, EdgeServiceOnboardingResultError, 'Unauthorized.');
    req.throwOn(500, EdgeServiceOnboardingResultError, 'Internal Server Error.');
    req.defaultToError(EdgeServiceOnboardingResultError, 'Unexpected error.');
    return req.callAsJson(serviceManagementResultSchema, requestOptions);
  }
}
